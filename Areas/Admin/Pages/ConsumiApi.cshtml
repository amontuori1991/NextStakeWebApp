@page
@model NextStakeWebApp.Areas.Admin.Pages.ConsumiApiModel
@using System.Text.Json
@{
    Layout = "/Pages/Shared/_Layout.cshtml";
    ViewData["Title"] = "Consumi API";

    var percCap = Model.DailyCap > 0
        ? Math.Min(100, Math.Round(Model.TodayTotal * 100.0 / Model.DailyCap, 1))
        : 0;
}

<div class="container py-4 consumi-page">

    <div class="d-flex justify-content-between align-items-center mb-3">
        <h3 class="mb-0">📊 Consumi API</h3>

        <div class="btn-group btn-group-sm theme-toggle" role="group" aria-label="Tema">
            <button type="button" class="btn btn-outline-secondary" data-theme-choice="dark">Dark</button>
            <button type="button" class="btn btn-outline-secondary" data-theme-choice="light">Light</button>
        </div>
    </div>

    <p class="text-muted mb-3">Storico chiamate API</p>

    <div class="row g-4 flex-column-reverse flex-lg-row">

        <!-- Tabella -->
        <div class="col-lg-6 d-flex align-items-center justify-content-center">
            <div class="card h-100 w-100">
                <div class="card-header">
                    Storico chiamate API
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-striped table-hover mb-0">
                            <thead>
                                <tr>
                                    <th>Data</th>
                                    <th>Contatore</th>
                                    <th>Origine</th>
                                </tr>
                            </thead>
                            <tbody id="consumi-tbody">
                                @if (!Model.Records.Any())
                                {
                                    <tr>
                                        <td colspan="3" class="text-center text-muted py-4">
                                            Nessun dato disponibile
                                        </td>
                                    </tr>
                                }
                                else
                                {
                                    @foreach (var r in Model.Records.OrderByDescending(x => x.Date))
                                    {
                                        <tr>
                                            <td>@r.Date.ToString("dd/MM/yyyy")</td>
                                            <td>@r.Counter</td>
                                            <td>@r.Origin</td>
                                        </tr>
                                    }
                                }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Grafico a torta -->
        <div class="col-lg-6">
            <div class="card h-100 w-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>Distribuzione per origine (giorno più recente)</span>

                    <div class="d-flex flex-column align-items-end">
                        <span id="daily-cap-badge" class="badge bg-secondary mb-1">
                            Tetto giornaliero: @Model.DailyCap
                        </span>
                        <small id="last-updated"
                               class="text-muted small">
                            Ultimo aggiornamento: --:--:--
                        </small>
                    </div>
                </div>

                <div class="card-body d-flex flex-column">

                    <div id="usage-summary" class="mb-2 small text-muted">
                        @if (Model.TodayTotal > 0)
                        {
                            <text>Ultimo giorno registrato: @Model.TodayTotal chiamate (@percCap% del tetto).</text>
                        }
                        else
                        {
                            <text>Nessun dato per il giorno più recente.</text>
                        }
                    </div>

                    <div id="usage-progress" class="usage-progress mb-3 @(Model.TodayTotal > 0 ? "" : "d-none")">
                        <div class="d-flex justify-content-between small mb-1">
                            <span>Utilizzo giornaliero</span>
                            <span id="usage-progress-label">@percCap% (@Model.TodayTotal / @Model.DailyCap)</span>
                        </div>
                        <div class="progress">
                            <div id="usage-progress-bar" class="progress-bar bg-info" role="progressbar"
                                 style="width:@percCap%"></div>
                        </div>
                    </div>

                    <div class="chart-wrapper">
                        <canvas id="apiUsagePie"></canvas>
                    </div>

                </div>
            </div>
        </div>

    </div> <!-- fine .row -->
</div> <!-- fine .container -->


<style>
    /* === Stesso sistema temi globali === */
    :root[data-theme="dark"] {
        --bg: linear-gradient(135deg, #252e40 0%, #1a2230 100%);
        --text: #e9edf3;
        --muted: rgba(255,255,255,.6);
        --card: rgba(255,255,255,0.06);
        --border: rgba(255,255,255,0.16);
    }

    :root[data-theme="light"] {
        --bg: #f0f2f5;
        --text: #1a2230;
        --muted: #566079;
        --card: #ffffff;
        --border: rgba(0,0,0,0.10);
    }

    html[data-theme] body {
        background: var(--bg);
        color: var(--text);
    }

    .consumi-page {
        color: var(--text);
    }

        .consumi-page .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            box-shadow: 0 10px 26px rgba(0,0,0,.25);
            backdrop-filter: blur(6px);
        }

        .consumi-page .card-header {
            font-weight: 600;
            border-bottom: 1px solid var(--border);
            background: transparent;
        }

        .consumi-page .text-muted {
            color: var(--muted) !important;
        }

    .theme-toggle .btn.active {
        background: #0d6efd;
        border-color: #0d6efd;
        color: #fff;
    }

    /* === Tabella leggibile in dark / light === */
    :root[data-theme="dark"] .consumi-page .table {
        --bs-table-color: #e9edf3;
        --bs-table-bg: transparent;
        --bs-table-striped-bg: rgba(255,255,255,.03);
        --bs-table-border-color: rgba(255,255,255,.18);
        --bs-table-hover-bg: rgba(255,255,255,.08);
    }

    :root[data-theme="light"] .consumi-page .table {
        --bs-table-color: #1a2230;
        --bs-table-bg: transparent;
        --bs-table-striped-bg: rgba(0,0,0,.015);
        --bs-table-border-color: rgba(0,0,0,.06);
        --bs-table-hover-bg: rgba(0,0,0,.03);
    }

    .consumi-page table th {
        font-size: .85rem;
        text-transform: uppercase;
        letter-spacing: .04em;
    }

    .consumi-page table td {
        font-size: .9rem;
    }
    /* === Forza il colore del testo tabella in base al tema === */
    :root[data-theme="dark"] .consumi-page .table thead th,
    :root[data-theme="dark"] .consumi-page .table tbody td {
        color: #e9edf3 !important; /* testo chiaro */
    }

    :root[data-theme="light"] .consumi-page .table thead th,
    :root[data-theme="light"] .consumi-page .table tbody td {
        color: #1a2230 !important; /* testo scuro */
    }

    /* === Barra di avanzamento === */
    .consumi-page .usage-progress .progress {
        height: 0.6rem;
        border-radius: 999px;
        overflow: hidden;
    }

    :root[data-theme="dark"] .consumi-page .usage-progress .progress {
        background-color: rgba(255,255,255,.12);
    }

    :root[data-theme="light"] .consumi-page .usage-progress .progress {
        background-color: rgba(0,0,0,.08);
    }

    /* === Grafico centrato, un po' più grande ma responsive === */
    .chart-wrapper {
        max-width: 360px;
        width: 100%;
        margin: 0 auto;
        padding: 1rem 0 0.5rem;
    }

        .chart-wrapper canvas {
            width: 100% !important;
            height: auto !important;
        }

    @@media (max-width: 768px) {
        .chart-wrapper {
            max-width: 260px;
        }
    }
</style>

<!-- Chart.js + plugin etichette -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

<script>
        // === Toggle tema (usa data-theme su <html>) ===
        (function () {
            function currentTheme() {
                const cookieMatch = document.cookie.match(/(?:^|;\s*)theme=([^;]+)/);
                const cookieValue = cookieMatch ? decodeURIComponent(cookieMatch[1]) : null;
                const stored = cookieValue || localStorage.getItem('theme');
                return (stored === 'light' || stored === 'dark') ? stored : 'dark';
            }

            function applyTheme(choice) {
                const applied = (choice === 'light') ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', applied);
                document.body.setAttribute('data-theme', applied);
            }

            function persist(choice) {
                const applied = (choice === 'light') ? 'light' : 'dark';
                localStorage.setItem('theme', applied);
                document.cookie = "theme=" + encodeURIComponent(applied)
                    + "; path=/; max-age=31536000; samesite=lax";
            }

            const btns = document.querySelectorAll('.consumi-page [data-theme-choice]');
            const initial = currentTheme();
            applyTheme(initial);

            btns.forEach(b => {
                if (b.getAttribute('data-theme-choice') === initial) {
                    b.classList.add('active');
                }
                b.addEventListener('click', () => {
                    const choice = b.getAttribute('data-theme-choice');
                    applyTheme(choice);
                    persist(choice);
                    btns.forEach(x => x.classList.remove('active'));
                    b.classList.add('active');
                });
            });
        })();

        // === Grafico + tabella + barra in realtime (polling ogni 3s) ===
        (function () {
            const DEFAULT_DAILY_CAP = 7500; // tetto giornaliero di default

            const REFRESH_MS = 3000;
            const canvas = document.getElementById('apiUsagePie');
            if (!canvas) return;

            const tbody = document.getElementById('consumi-tbody');
            const summaryEl = document.getElementById('usage-summary');
            const progressBlock = document.getElementById('usage-progress');
            const progressLabel = document.getElementById('usage-progress-label');
            const progressBar = document.getElementById('usage-progress-bar');
            const capBadge = document.getElementById('daily-cap-badge');
            const lastUpdatedEl = document.getElementById('last-updated');

            let pieChart = null;

            function getTextColor() {
                const computed = getComputedStyle(document.documentElement);
                const c = computed.getPropertyValue('--text').trim();
                return c || '#ffffff';
            }

            function buildOrUpdateChart(dailyCap, todayUsage) {
                // se non ci sono dati, distruggo il grafico e basta
                if (!todayUsage || !todayUsage.length) {
                    if (pieChart) {
                        pieChart.destroy();
                        pieChart = null;
                    }
                    return;
                }

                const originLabels = todayUsage.map(x => x.origin);
                const originCounters = todayUsage.map(x => x.counter);
                const usedToday = originCounters.reduce((a, b) => a + b, 0);

                let labels, data;

                if (dailyCap > 0) {
                    const remaining = Math.max(0, dailyCap - usedToday);
                    labels = ['Disponibile', ...originLabels];
                    data = [remaining, ...originCounters];
                } else {
                    // nessun tetto impostato → grafico solo delle origini
                    labels = [...originLabels];
                    data = [...originCounters];
                }

                const colors = [
                    '#6c757d', // Disponibile (se presente)
                    '#0d6efd', '#6610f2', '#198754', '#dc3545', '#fd7e14',
                    '#20c997', '#6f42c1', '#0dcaf0', '#ffc107'
                ];

                if (!pieChart) {
                    Chart.register(ChartDataLabels);

                    pieChart = new Chart(canvas, {
                        type: 'pie',
                        data: {
                            labels: labels,
                            datasets: [{
                                data: data,
                                backgroundColor: labels.map((_, i) => colors[i % colors.length]),
                                borderColor: '#ffffff',
                                borderWidth: 2
                            }]
                        },
                        options: {
                            plugins: {
                                legend: {
                                    position: 'right',
                                    labels: {
                                        usePointStyle: true,
                                        boxWidth: 10,
                                        padding: 14,
                                        color: getTextColor()
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function (context) {
                                            const val = context.raw || 0;
                                            let denom, perc, suffix;

                                            if (dailyCap > 0) {
                                                denom = dailyCap;
                                                perc = denom ? (val / denom * 100) : 0;
                                                suffix = 'del tetto';
                                            } else {
                                                denom = usedToday || 1;
                                                perc = val / denom * 100;
                                                suffix = 'del totale del giorno';
                                            }

                                            return `${context.label}: ${val} chiamate (${perc.toFixed(2)}% ${suffix})`;
                                        }
                                    }
                                },
                                datalabels: {
                                    color: '#ffffff',
                                    font: {
                                        weight: 'bold',
                                        size: 11
                                    },
                                    formatter: function (value) {
                                        let denom;
                                        if (dailyCap > 0) {
                                            denom = dailyCap;
                                        } else {
                                            denom = usedToday || 1;
                                        }
                                        const perc = value / denom * 100;
                                        return perc >= 3 ? perc.toFixed(1) + '%' : '';
                                    }
                                }
                            }
                        }
                    });
                } else {
                    pieChart.data.labels = labels;
                    pieChart.data.datasets[0].data = data;
                    pieChart.options.plugins.legend.labels.color = getTextColor();
                    pieChart.update();
                }
            }

            function renderTable(records) {
                if (!tbody) return;

                if (!records || !records.length) {
                    tbody.innerHTML = `
    <tr>
      <td colspan="3" class="text-center text-muted py-4">
        Nessun dato disponibile
      </td>
    </tr>`;
                    return;
                }

                const rowsHtml = records
                    .sort((a, b) => new Date(b.date) - new Date(a.date))
                    .map(r => {
                        const d = new Date(r.date);
                        const dateStr = d.toLocaleDateString('it-IT');
                        return `
    <tr>
      <td>${dateStr}</td>
      <td>${r.counter}</td>
      <td>${r.origin}</td>
    </tr>`;
                    })
                    .join('');

                tbody.innerHTML = rowsHtml;
            }

            function renderSummaryAndProgress(dailyCap, todayTotal) {
                // testo di riepilogo
                if (summaryEl) {
                    if (todayTotal > 0 && dailyCap > 0) {
                        const percCap = Math.min(100, Math.round(todayTotal * 1000.0 / dailyCap) / 10);
                        summaryEl.textContent = `Ultimo giorno registrato: ${todayTotal} chiamate (${percCap}% del tetto).`;
                    } else if (todayTotal > 0) {
                        summaryEl.textContent = `Ultimo giorno registrato: ${todayTotal} chiamate. (tetto non impostato)`;
                    } else {
                        summaryEl.textContent = 'Nessun dato per il giorno più recente.';
                    }
                }

                // barra di avanzamento
                if (!progressBlock || !progressLabel || !progressBar) return;

                if (todayTotal > 0) {
                    progressBlock.classList.remove('d-none');

                    if (dailyCap > 0) {
                        const percCap = Math.min(100, Math.round(todayTotal * 1000.0 / dailyCap) / 10);
                        progressLabel.textContent = `${percCap}% (${todayTotal} / ${dailyCap})`;
                        progressBar.style.width = `${percCap}%`;
                    } else {
                        // nessun tetto: la barra va al 100% e mostra solo il numero di chiamate
                        progressLabel.textContent = `${todayTotal} chiamate (tetto non impostato)`;
                        progressBar.style.width = '100%';
                    }
                } else {
                    progressBlock.classList.add('d-none');
                }
            }

            async function loadConsumi() {
                try {
                    const res = await fetch('/admin/api/consumi', { cache: 'no-store' });
                    if (!res.ok) return;

                        const payload = await res.json();

    // se l'API manda 0, usiamo il tetto di default (7500)
    const rawDailyCap = payload.dailyCap || 0;
    const dailyCap = rawDailyCap > 0 ? rawDailyCap : DEFAULT_DAILY_CAP;

    const todayTotal = payload.todayTotal || 0;
    const todayUsage = payload.todayUsage || [];
    const records = payload.records || [];
    

                    // badge tetto
                    if (capBadge) {
                        capBadge.textContent = `Tetto giornaliero: ${dailyCap}`;
                    }

                    // orario ultimo aggiornamento
                    if (lastUpdatedEl) {
                        const now = new Date();
                        const timeStr = now.toLocaleTimeString('it-IT', {
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        lastUpdatedEl.textContent = `Ultimo aggiornamento: ${timeStr}`;
                    }

                    renderTable(records);
                    renderSummaryAndProgress(dailyCap, todayTotal);
                    buildOrUpdateChart(dailyCap, todayUsage);
                } catch (err) {
                    console.error('[Consumi] errore caricamento dati', err);
                }
            }

            // Bootstrap + polling ogni 3s
            loadConsumi();
            setInterval(loadConsumi, REFRESH_MS);
        })();
</script>
